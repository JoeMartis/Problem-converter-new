<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Open edX OLX Problem Converter</title>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&family=Crimson+Pro:wght@400;600;700&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mammoth/1.6.0/mammoth.browser.min.js"></script>

    <!-- MathJax Configuration -->
    <script>
        window.MathJax = {
            tex: {
                inlineMath: [['\\(', '\\)'], ['$', '$']],
                displayMath: [['\\[', '\\]'], ['$$', '$$']],
                processEscapes: true,
                processEnvironments: true
            },
            options: {
                skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
            }
        };
    </script>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

    <style>
        :root {
            --bg-primary: #0f1419;
            --bg-secondary: #1a2332;
            --bg-tertiary: #253447;
            --accent-primary: #00d4aa;
            --accent-secondary: #00a8e8;
            --text-primary: #e8f4f8;
            --text-secondary: #8fa3b0;
            --border: #2d3f54;
            --success: #00d4aa;
            --warning: #ffd93d;
            --error: #ff6b6b;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Crimson Pro', serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            line-height: 1.6;
            min-height: 100vh;
        }
        
        .container {
            max-width: 1600px;
            margin: 0 auto;
            padding: 40px 20px;
        }
        
        header {
            text-align: center;
            margin-bottom: 40px;
            position: relative;
        }
        
        h1 {
            font-size: 3rem;
            font-weight: 700;
            margin-bottom: 12px;
            background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            letter-spacing: -0.02em;
            animation: slideDown 0.6s ease-out;
        }
        
        .subtitle {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.95rem;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.15em;
            animation: fadeIn 0.8s ease-out 0.2s both;
        }
        
        /* Statistics Dashboard */
        .stats-dashboard {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            gap: 15px;
            margin-bottom: 30px;
            animation: fadeIn 0.8s ease-out 0.3s both;
        }
        
        .stat-card {
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: 10px;
            padding: 20px;
            text-align: center;
            transition: all 0.3s ease;
        }
        
        .stat-card:hover {
            transform: translateY(-3px);
            border-color: var(--accent-primary);
            box-shadow: 0 8px 24px rgba(0, 212, 170, 0.15);
        }
        
        .stat-value {
            font-family: 'JetBrains Mono', monospace;
            font-size: 2rem;
            font-weight: 700;
            color: var(--accent-primary);
            display: block;
        }
        
        .stat-label {
            font-size: 0.85rem;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-top: 5px;
        }
        
        .stat-card.warning .stat-value {
            color: var(--warning);
        }
        
        .stat-card.error .stat-value {
            color: var(--error);
        }
        
        .main-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 25px;
            animation: fadeIn 1s ease-out 0.4s both;
        }
        
        .main-grid.three-col {
            grid-template-columns: 1fr 1fr 1fr;
        }
        
        .panel {
            background: var(--bg-secondary);
            border-radius: 12px;
            border: 1px solid var(--border);
            overflow: hidden;
            display: flex;
            flex-direction: column;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }
        
        .panel:hover {
            transform: translateY(-2px);
            box-shadow: 0 12px 40px rgba(0, 212, 170, 0.1);
        }
        
        .panel-header {
            background: var(--bg-tertiary);
            padding: 16px 20px;
            border-bottom: 1px solid var(--border);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .panel-title {
            font-size: 1rem;
            font-weight: 600;
            color: var(--accent-primary);
            font-family: 'JetBrains Mono', monospace;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }
        
        .panel-badge {
            background: var(--accent-primary);
            color: var(--bg-primary);
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.75rem;
            padding: 4px 10px;
            border-radius: 12px;
            font-weight: 600;
        }
        
        .panel-body {
            padding: 20px;
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        
        textarea {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.85rem;
            background: var(--bg-primary);
            color: var(--text-primary);
            border: 2px solid var(--border);
            border-radius: 8px;
            padding: 16px;
            resize: vertical;
            min-height: 450px;
            flex: 1;
            transition: border-color 0.3s ease, box-shadow 0.3s ease;
            line-height: 1.5;
        }
        
        textarea:focus {
            outline: none;
            border-color: var(--accent-primary);
            box-shadow: 0 0 0 3px rgba(0, 212, 170, 0.1);
        }
        
        textarea::placeholder {
            color: var(--text-secondary);
            opacity: 0.5;
        }
        
        .controls {
            display: flex;
            gap: 12px;
            margin-bottom: 25px;
            flex-wrap: wrap;
            animation: fadeIn 1s ease-out 0.6s both;
        }
        
        button {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.85rem;
            font-weight: 600;
            padding: 12px 22px;
            background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
            color: var(--bg-primary);
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            position: relative;
            overflow: hidden;
        }
        
        button:before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.3);
            transform: translate(-50%, -50%);
            transition: width 0.6s, height 0.6s;
        }
        
        button:hover:before {
            width: 300px;
            height: 300px;
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 24px rgba(0, 212, 170, 0.3);
        }
        
        button:active {
            transform: translateY(0);
        }
        
        button span {
            position: relative;
            z-index: 1;
        }
        
        button.secondary {
            background: var(--bg-tertiary);
            color: var(--text-primary);
            border: 2px solid var(--border);
        }
        
        button.secondary:hover {
            border-color: var(--accent-primary);
            box-shadow: 0 8px 24px rgba(0, 212, 170, 0.15);
        }
        
        .output-actions {
            display: flex;
            gap: 10px;
            margin-bottom: 12px;
            flex-wrap: wrap;
        }
        
        .output-actions button {
            font-size: 0.75rem;
            padding: 8px 14px;
        }
        
        pre {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.8rem;
            background: var(--bg-primary);
            color: var(--text-primary);
            border: 2px solid var(--border);
            border-radius: 8px;
            padding: 16px;
            overflow-x: auto;
            overflow-y: auto;
            max-height: 450px;
            flex: 1;
            line-height: 1.5;
            white-space: pre-wrap;
            word-wrap: break-word;
        }
        
        /* Preview Pane Styles */
        .preview-container {
            background: var(--bg-primary);
            border: 2px solid var(--border);
            border-radius: 8px;
            padding: 0;
            overflow-y: auto;
            max-height: 500px;
            flex: 1;
        }
        
        .preview-problem {
            padding: 20px;
            border-bottom: 1px solid var(--border);
            transition: background 0.2s ease;
        }
        
        .preview-problem:last-child {
            border-bottom: none;
        }
        
        .preview-problem:hover {
            background: rgba(0, 212, 170, 0.03);
        }
        
        .preview-problem-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }
        
        .preview-problem-title {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.8rem;
            color: var(--accent-secondary);
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }
        
        .preview-problem-type {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.7rem;
            padding: 3px 8px;
            border-radius: 4px;
            background: var(--bg-tertiary);
            color: var(--text-secondary);
        }
        
        .preview-problem-type.multiple-choice {
            background: rgba(0, 168, 232, 0.2);
            color: var(--accent-secondary);
        }
        
        .preview-problem-type.checkbox {
            background: rgba(0, 212, 170, 0.2);
            color: var(--accent-primary);
        }
        
        .preview-problem-type.numerical {
            background: rgba(255, 217, 61, 0.2);
            color: var(--warning);
        }
        
        .preview-problem-type.text {
            background: rgba(168, 218, 220, 0.2);
            color: #a8dadc;
        }
        
        .preview-question {
            font-size: 1.1rem;
            color: var(--text-primary);
            margin-bottom: 15px;
            line-height: 1.5;
        }
        
        .preview-choices {
            list-style: none;
            padding: 0;
            margin: 0 0 15px 0;
        }
        
        .preview-choice {
            display: flex;
            align-items: flex-start;
            padding: 10px 12px;
            margin: 6px 0;
            background: var(--bg-secondary);
            border-radius: 6px;
            border: 1px solid var(--border);
            transition: all 0.2s ease;
            cursor: default;
        }
        
        .preview-choice:hover {
            border-color: var(--accent-primary);
        }
        
        .preview-choice.correct {
            border-color: var(--success);
            background: rgba(0, 212, 170, 0.1);
        }
        
        .preview-choice-indicator {
            width: 18px;
            height: 18px;
            border: 2px solid var(--border);
            border-radius: 50%;
            margin-right: 12px;
            flex-shrink: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-top: 2px;
        }
        
        .preview-choice-indicator.checkbox {
            border-radius: 4px;
        }
        
        .preview-choice.correct .preview-choice-indicator {
            border-color: var(--success);
            background: var(--success);
        }
        
        .preview-choice.correct .preview-choice-indicator::after {
            content: '‚úì';
            color: var(--bg-primary);
            font-size: 12px;
            font-weight: bold;
        }
        
        .preview-choice-text {
            color: var(--text-primary);
            font-size: 0.95rem;
            flex: 1;
        }
        
        .preview-input-field {
            background: var(--bg-secondary);
            border: 2px solid var(--border);
            border-radius: 6px;
            padding: 10px 14px;
            color: var(--text-secondary);
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.9rem;
            width: 200px;
            margin-bottom: 15px;
        }
        
        .preview-answer-hint {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.8rem;
            color: var(--success);
            margin-bottom: 15px;
        }
        
        .preview-explanation {
            background: var(--bg-tertiary);
            border-left: 3px solid var(--accent-primary);
            padding: 12px 16px;
            border-radius: 0 6px 6px 0;
            margin-top: 10px;
        }
        
        .preview-explanation-label {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.75rem;
            color: var(--accent-primary);
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-bottom: 6px;
        }
        
        .preview-explanation-text {
            color: var(--text-secondary);
            font-size: 0.9rem;
            line-height: 1.5;
        }
        
        .preview-empty {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 300px;
            color: var(--text-secondary);
        }
        
        .preview-empty-icon {
            font-size: 3rem;
            margin-bottom: 15px;
            opacity: 0.5;
        }
        
        .preview-nav {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 12px;
        }
        
        .preview-nav button {
            padding: 6px 12px;
            font-size: 0.75rem;
        }
        
        .preview-nav-info {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.8rem;
            color: var(--text-secondary);
        }
        
        /* Editor Styles */
        .editor-toolbar {
            display: flex;
            gap: 4px;
            padding: 8px 12px;
            background: var(--bg-tertiary);
            border-radius: 6px;
            margin-bottom: 12px;
            flex-wrap: wrap;
            align-items: center;
        }
        
        .editor-toolbar-group {
            display: flex;
            gap: 2px;
            padding-right: 10px;
            border-right: 1px solid var(--border);
            margin-right: 6px;
        }
        
        .editor-toolbar-group:last-child {
            border-right: none;
            margin-right: 0;
            padding-right: 0;
        }
        
        .editor-btn {
            width: 32px;
            height: 32px;
            padding: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            background: transparent;
            border: 1px solid transparent;
            border-radius: 4px;
            color: var(--text-secondary);
            font-size: 0.85rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .editor-btn:hover {
            background: var(--bg-secondary);
            border-color: var(--border);
            color: var(--text-primary);
            transform: none;
            box-shadow: none;
        }
        
        .editor-btn:hover::before {
            display: none;
        }
        
        .editor-btn.active {
            background: var(--accent-primary);
            color: var(--bg-primary);
        }
        
        .editor-btn svg {
            width: 16px;
            height: 16px;
        }
        
        .editable {
            outline: none;
            border-radius: 4px;
            padding: 4px 6px;
            margin: -4px -6px;
            transition: all 0.2s ease;
            min-height: 1.5em;
        }
        
        .editable:hover {
            background: rgba(0, 212, 170, 0.05);
        }
        
        .editable:focus {
            background: rgba(0, 212, 170, 0.1);
            box-shadow: 0 0 0 2px rgba(0, 212, 170, 0.3);
        }
        
        .editable a {
            color: var(--accent-secondary);
            text-decoration: underline;
        }
        
        .editable strong, .editable b {
            font-weight: bold;
        }
        
        .editable em, .editable i {
            font-style: italic;
        }
        
        .editable u {
            text-decoration: underline;
        }
        
        .editable code {
            font-family: 'JetBrains Mono', monospace;
            background: var(--bg-tertiary);
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 0.9em;
        }
        
        .editable pre {
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 6px;
            padding: 12px 16px;
            margin: 10px 0;
            overflow-x: auto;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.85em;
            line-height: 1.5;
        }
        
        .editable pre code {
            background: transparent;
            padding: 0;
            border-radius: 0;
        }
        
        .editable sup {
            vertical-align: super;
            font-size: 0.8em;
        }
        
        .editable sub {
            vertical-align: sub;
            font-size: 0.8em;
        }
        
        .edit-mode-indicator {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.7rem;
            color: var(--warning);
            background: rgba(255, 217, 61, 0.15);
            padding: 4px 10px;
            border-radius: 4px;
            margin-left: 10px;
        }
        
        .edit-mode-indicator::before {
            content: '‚úé';
        }
        
        /* Link Dialog */
        .link-dialog-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
        }
        
        .link-dialog-overlay.visible {
            opacity: 1;
            visibility: visible;
        }
        
        .link-dialog {
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 24px;
            width: 400px;
            max-width: 90vw;
            transform: translateY(-20px);
            transition: transform 0.3s ease;
        }
        
        .link-dialog-overlay.visible .link-dialog {
            transform: translateY(0);
        }
        
        .link-dialog h3 {
            color: var(--accent-primary);
            margin-bottom: 16px;
            font-size: 1.1rem;
        }
        
        .link-dialog label {
            display: block;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.8rem;
            color: var(--text-secondary);
            margin-bottom: 6px;
            text-transform: uppercase;
        }
        
        .link-dialog input {
            width: 100%;
            padding: 10px 14px;
            background: var(--bg-primary);
            border: 2px solid var(--border);
            border-radius: 6px;
            color: var(--text-primary);
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.9rem;
            margin-bottom: 16px;
        }
        
        .link-dialog input:focus {
            outline: none;
            border-color: var(--accent-primary);
        }
        
        .link-dialog select {
            width: 100%;
            padding: 10px 14px;
            background: var(--bg-primary);
            border: 2px solid var(--border);
            border-radius: 6px;
            color: var(--text-primary);
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.9rem;
            margin-bottom: 16px;
            cursor: pointer;
        }
        
        .link-dialog select:focus {
            outline: none;
            border-color: var(--accent-primary);
        }
        
        .link-dialog select option {
            background: var(--bg-secondary);
            color: var(--text-primary);
        }
        
        .link-dialog textarea {
            width: 100%;
            padding: 10px 14px;
            background: var(--bg-primary);
            border: 2px solid var(--border);
            border-radius: 6px;
            color: var(--text-primary);
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.85rem;
            margin-bottom: 16px;
            resize: vertical;
            min-height: 100px;
        }
        
        .link-dialog textarea:focus {
            outline: none;
            border-color: var(--accent-primary);
        }
        
        .link-checkbox {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 20px;
        }
        
        .link-checkbox input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--accent-primary);
            cursor: pointer;
        }
        
        .link-checkbox label {
            display: inline;
            margin-bottom: 0;
            cursor: pointer;
            color: var(--text-primary);
        }
        
        .link-dialog-buttons {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
        }
        
        .link-dialog-buttons button {
            padding: 10px 20px;
            font-size: 0.8rem;
        }
        
        .status {
            padding: 12px 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.85rem;
            display: none;
            animation: slideIn 0.3s ease-out;
        }
        
        .status.success {
            background: rgba(0, 212, 170, 0.1);
            border: 1px solid var(--success);
            color: var(--success);
            display: block;
        }
        
        .status.error {
            background: rgba(255, 107, 107, 0.1);
            border: 1px solid var(--error);
            color: var(--error);
            display: block;
        }
        
        .info-panel {
            background: var(--bg-secondary);
            border-radius: 12px;
            border: 1px solid var(--border);
            padding: 25px;
            margin-top: 25px;
            animation: fadeIn 1s ease-out 0.8s both;
        }
        
        .info-panel h2 {
            font-size: 1.3rem;
            color: var(--accent-primary);
            margin-bottom: 15px;
            font-weight: 600;
        }
        
        .info-panel ul {
            list-style: none;
            padding-left: 0;
        }
        
        .info-panel li {
            padding: 10px 0;
            border-bottom: 1px solid var(--border);
            color: var(--text-secondary);
            font-size: 0.95rem;
        }
        
        .info-panel li:last-child {
            border-bottom: none;
        }
        
        .info-panel li:before {
            content: '‚Üí';
            color: var(--accent-primary);
            margin-right: 12px;
            font-weight: bold;
        }
        
        /* Toggle for preview */
        .toggle-container {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .toggle-label {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.8rem;
            color: var(--text-secondary);
        }
        
        .toggle {
            position: relative;
            width: 44px;
            height: 24px;
            background: var(--bg-tertiary);
            border-radius: 12px;
            cursor: pointer;
            transition: background 0.3s ease;
            border: 2px solid var(--border);
        }
        
        .toggle.active {
            background: var(--accent-primary);
            border-color: var(--accent-primary);
        }
        
        .toggle-knob {
            position: absolute;
            top: 2px;
            left: 2px;
            width: 16px;
            height: 16px;
            background: var(--text-primary);
            border-radius: 50%;
            transition: transform 0.3s ease;
        }
        
        .toggle.active .toggle-knob {
            transform: translateX(20px);
        }
        
        @keyframes slideDown {
            from {
                opacity: 0;
                transform: translateY(-30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        @keyframes fadeIn {
            from {
                opacity: 0;
            }
            to {
                opacity: 1;
            }
        }
        
        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateX(-20px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }
        
        @media (max-width: 1200px) {
            .main-grid.three-col {
                grid-template-columns: 1fr 1fr;
            }
        }
        
        @media (max-width: 900px) {
            .main-grid,
            .main-grid.three-col {
                grid-template-columns: 1fr;
            }
            
            h1 {
                font-size: 2.2rem;
            }
            
            .stats-dashboard {
                grid-template-columns: repeat(3, 1fr);
            }
        }
        
        @media (max-width: 500px) {
            .stats-dashboard {
                grid-template-columns: repeat(2, 1fr);
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>OLX Problem Converter <span style="font-size: 0.4em; font-weight: 400; color: var(--text-secondary); -webkit-text-fill-color: var(--text-secondary);">v2.0</span></h1>
            <p class="subtitle">Open edX ‚Ä¢ Multiple Choice ‚Ä¢ Problem Bank ‚Ä¢ LaTeX Support</p>
        </header>
        
        <!-- Statistics Dashboard -->
        <div class="stats-dashboard">
            <div class="stat-card" id="stat-total">
                <span class="stat-value">0</span>
                <div class="stat-label">Problems</div>
            </div>
            <div class="stat-card" id="stat-mc">
                <span class="stat-value">0</span>
                <div class="stat-label">Single Choice</div>
            </div>
            <div class="stat-card" id="stat-checkbox">
                <span class="stat-value">0</span>
                <div class="stat-label">Multi-Select</div>
            </div>
            <div class="stat-card" id="stat-numerical">
                <span class="stat-value">0</span>
                <div class="stat-label">Numerical</div>
            </div>
            <div class="stat-card" id="stat-text">
                <span class="stat-value">0</span>
                <div class="stat-label">Text Input</div>
            </div>
            <div class="stat-card" id="stat-choices">
                <span class="stat-value">0</span>
                <div class="stat-label">Avg Choices</div>
            </div>
            <div class="stat-card" id="stat-warnings">
                <span class="stat-value">0</span>
                <div class="stat-label">Warnings</div>
            </div>
        </div>
        
        <div class="controls">
            <button onclick="convertToOLX()"><span>Convert to OLX</span></button>
            <button class="secondary" onclick="clearAll()"><span>Clear All</span></button>
            <button class="secondary" onclick="loadSample()"><span>Load Sample</span></button>
            <button class="secondary" onclick="document.getElementById('fileInput').click()"><span>Upload File</span></button>
            <input type="file" id="fileInput" accept=".txt,.docx" style="display: none;" onchange="handleFileUpload(event)">
            <button class="secondary" onclick="showChuckNorrisQuote()" style="margin-left: 20px;"><span>üòÑ Chuck Norris Quote</span></button>
            <div class="toggle-container" style="margin-left: auto;">
                <span class="toggle-label">Show Preview</span>
                <div class="toggle active" id="previewToggle" onclick="togglePreview()">
                    <div class="toggle-knob"></div>
                </div>
            </div>
        </div>
        
        <div id="status" class="status"></div>
        
        <div class="main-grid three-col" id="mainGrid">
            <div class="panel">
                <div class="panel-header">
                    <span class="panel-title">Input</span>
                </div>
                <div class="panel-body">
                    <textarea id="input" placeholder="Paste your problem text here...

Example format:

What type of data is best visualized with a bar chart?
Continuous time series data
Relationships between variables
Discrete categorical comparisons (correct)
Cumulative totals
Explanation: Bar charts are ideal for comparing discrete categories.

Which scenario is best suited for a bar chart?
Comparing sales across product categories (correct)
Tracking stock prices throughout the day
Examining the relationship between variables
Plotting a sine wave
Explanation: Sales by category represents distinct groups."></textarea>
                </div>
            </div>
            
            <div class="panel" id="previewPanel">
                <div class="panel-header">
                    <span class="panel-title">Preview & Edit</span>
                    <div style="display: flex; align-items: center;">
                        <span class="panel-badge" id="previewCount">0 Problems</span>
                        <span class="edit-mode-indicator" id="editIndicator" style="display: none;">Edit Mode</span>
                    </div>
                </div>
                <div class="panel-body">
                    <!-- Editor Toolbar -->
                    <div class="editor-toolbar" id="editorToolbar">
                        <div class="editor-toolbar-group">
                            <button class="editor-btn" onclick="formatText('bold')" title="Bold (Ctrl+B)"><strong>B</strong></button>
                            <button class="editor-btn" onclick="formatText('italic')" title="Italic (Ctrl+I)"><em>I</em></button>
                            <button class="editor-btn" onclick="formatText('underline')" title="Underline (Ctrl+U)"><u>U</u></button>
                        </div>
                        <div class="editor-toolbar-group">
                            <button class="editor-btn" onclick="formatText('superscript')" title="Superscript">x¬≤</button>
                            <button class="editor-btn" onclick="formatText('subscript')" title="Subscript">x‚ÇÇ</button>
                        </div>
                        <div class="editor-toolbar-group">
                            <button class="editor-btn" onclick="wrapInlineCode()" title="Inline Code (Ctrl+`)">{ }</button>
                            <button class="editor-btn" onclick="showCodeDialog()" title="Code Block">‚ñ§</button>
                        </div>
                        <div class="editor-toolbar-group">
                            <button class="editor-btn" onclick="showLinkDialog()" title="Insert Link (Ctrl+K)">üîó</button>
                            <button class="editor-btn" onclick="removeLink()" title="Remove Link">‚úÇ</button>
                        </div>
                        <div class="editor-toolbar-group">
                            <button class="editor-btn" onclick="showLatexDialog()" title="Insert LaTeX Equation">‚àë</button>
                        </div>
                        <div class="editor-toolbar-group">
                            <button class="editor-btn" onclick="formatText('removeFormat')" title="Clear Formatting">‚äò</button>
                        </div>
                    </div>
                    
                    <div class="preview-nav" id="previewNav" style="display: none;">
                        <button class="secondary" onclick="prevProblem()"><span>‚Üê Prev</span></button>
                        <span class="preview-nav-info" id="previewNavInfo">1 of 1</span>
                        <button class="secondary" onclick="nextProblem()"><span>Next ‚Üí</span></button>
                        <button class="secondary" onclick="showAllProblems()" style="margin-left: auto;"><span>Show All</span></button>
                    </div>
                    <div class="preview-container" id="previewContainer">
                        <div class="preview-empty">
                            <div class="preview-empty-icon">üìù</div>
                            <div>Convert problems to see preview</div>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="panel">
                <div class="panel-header">
                    <span class="panel-title">Output (OLX)</span>
                </div>
                <div class="panel-body">
                    <div class="output-actions">
                        <button onclick="copyOutput()"><span>Copy</span></button>
                        <button class="secondary" onclick="downloadOutput()"><span>Download XML</span></button>
                        <button class="secondary" onclick="downloadLibrary()"><span>Download Library</span></button>
                    </div>
                    <pre id="output">OLX output will appear here...</pre>
                </div>
            </div>
        </div>
        
        <div class="info-panel">
            <h2>How to Use</h2>
            <ul>
                <li>Upload a .txt or .docx file, or paste problem text directly into the input area</li>
                <li>Each question should end with a question mark (?)</li>
                <li>List answer choices below each question (one per line)</li>
                <li>Mark correct answers with (correct) or (correct answer)</li>
                <li>Add "Explanation:" followed by your explanation text (optional)</li>
                <li>Click "Convert to OLX" to generate Open edX XML</li>
                <li><strong>Edit in Preview:</strong> Click any question, choice, or explanation to edit. Use the toolbar to add formatting, links, and more!</li>
            </ul>
        </div>
    </div>
    
    <!-- Link Dialog -->
    <div class="link-dialog-overlay" id="linkDialog">
        <div class="link-dialog">
            <h3>Insert Link</h3>
            <label for="linkUrl">URL</label>
            <input type="url" id="linkUrl" placeholder="https://example.com">
            <label for="linkText">Link Text (optional)</label>
            <input type="text" id="linkText" placeholder="Display text">
            <div class="link-checkbox">
                <input type="checkbox" id="linkTarget" checked>
                <label for="linkTarget">Open in new tab</label>
            </div>
            <div class="link-dialog-buttons">
                <button class="secondary" onclick="closeLinkDialog()"><span>Cancel</span></button>
                <button onclick="insertLink()"><span>Insert Link</span></button>
            </div>
        </div>
    </div>
    
    <!-- Code Dialog -->
    <div class="link-dialog-overlay" id="codeDialog">
        <div class="link-dialog">
            <h3>Insert Code</h3>
            <label for="codeType">Code Type</label>
            <select id="codeType">
                <option value="inline">Inline Code</option>
                <option value="block">Code Block</option>
            </select>
            <label for="codeLanguage">Language (optional)</label>
            <input type="text" id="codeLanguage" placeholder="e.g., python, javascript">
            <label for="codeContent">Code</label>
            <textarea id="codeContent" rows="6" placeholder="Enter your code here..."></textarea>
            <div class="link-dialog-buttons">
                <button class="secondary" onclick="closeCodeDialog()"><span>Cancel</span></button>
                <button onclick="insertCodeBlock()"><span>Insert Code</span></button>
            </div>
        </div>
    </div>

    <!-- LaTeX Dialog -->
    <div class="link-dialog-overlay" id="latexDialog">
        <div class="link-dialog">
            <h3>Insert LaTeX Equation</h3>
            <label for="latexType">Equation Type</label>
            <select id="latexType">
                <option value="inline">Inline \( \) - Parentheses</option>
                <option value="inline-dollar">Inline $ $ - Dollar signs</option>
                <option value="display">Display \[ \] - Brackets</option>
                <option value="display-dollar">Display $$ $$ - Double dollar</option>
            </select>
            <label for="latexContent">LaTeX Code</label>
            <textarea id="latexContent" rows="6" placeholder="e.g., x = \frac{-b \pm \sqrt{b^2 - 4ac}}{2a}"></textarea>
            <div style="margin-top: 10px; font-size: 0.9em; color: var(--text-muted);">
                <strong>Preview:</strong>
                <div id="latexPreview" style="margin-top: 8px; padding: 10px; background: var(--bg-tertiary); border-radius: 4px; min-height: 40px;"></div>
            </div>
            <div style="margin-top: 10px; font-size: 0.85em; color: var(--text-muted);">
                <strong>Common symbols:</strong> \frac{a}{b}, \sqrt{x}, x^2, x_i, \sum, \int, \alpha, \beta, \gamma
            </div>
            <div class="link-dialog-buttons">
                <button class="secondary" onclick="closeLatexDialog()"><span>Cancel</span></button>
                <button onclick="insertLatex()"><span>Insert Equation</span></button>
            </div>
        </div>
    </div>

    <!-- Chuck Norris Quote Dialog -->
    <div class="link-dialog-overlay" id="chuckNorrisDialog">
        <div class="link-dialog">
            <h3>üòÑ Chuck Norris Quote</h3>
            <div id="chuckNorrisQuoteContent" style="margin: 20px 0; padding: 20px; background: var(--bg-tertiary); border-radius: 8px; border-left: 4px solid var(--accent-cyan); font-size: 1.1em; line-height: 1.6; min-height: 80px; display: flex; align-items: center; justify-content: center; text-align: center; color: var(--text-primary);">
                <span style="opacity: 0.5;">Loading...</span>
            </div>
            <div class="link-dialog-buttons">
                <button class="secondary" onclick="closeChuckNorrisDialog()"><span>Close</span></button>
                <button onclick="fetchNewChuckNorrisQuote()"><span>Another Quote</span></button>
            </div>
        </div>
    </div>

    <script>
        let currentProblems = [];
        let currentPreviewIndex = 0;
        let showAllMode = true;
        let previewEnabled = true;
        let savedSelection = null;
        let editListenersInitialized = false;
        
        function escapeXml(str) {
            if (!str) return '';
            return str
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&apos;');
        }

        function escapeHtml(str) {
            if (!str) return '';
            const div = document.createElement('div');
            div.textContent = str;
            return div.innerHTML;
        }

        function escapeHtmlWithFormatting(text) {
            if (!text) return '';

            // Allow safe formatting tags: strong, em, u, sup, sub, code, a, b, i, pre
            const allowedTags = ['strong', 'em', 'u', 'sup', 'sub', 'code', 'a', 'b', 'i', 'pre'];
            let result = text;
            const tagPlaceholders = {};
            let placeholderIndex = 0;

            // Protect LaTeX expressions (both inline and display)
            // Inline: \( ... \) or $ ... $
            // Display: \[ ... \] or $$ ... $$
            const latexPatterns = [
                { regex: /\\\[([\s\S]*?)\\\]/g, prefix: '\\[', suffix: '\\]' },
                { regex: /\\\(([\s\S]*?)\\\)/g, prefix: '\\(', suffix: '\\)' },
                { regex: /\$\$([\s\S]*?)\$\$/g, prefix: '$$', suffix: '$$' },
                { regex: /\$([^\$\n]+?)\$/g, prefix: '$', suffix: '$' }
            ];

            latexPatterns.forEach(pattern => {
                result = result.replace(pattern.regex, (match, content) => {
                    const placeholder = `__LATEX_${placeholderIndex}__`;
                    tagPlaceholders[placeholder] = pattern.prefix + content + pattern.suffix;
                    placeholderIndex++;
                    return placeholder;
                });
            });

            // Protect anchor tags with href
            const anchorRegex = /<a\s+href="([^"]+)"(?:\s+target="([^"]+)")?(?:\s+rel="([^"]+)")?[^>]*>(.*?)<\/a>/gi;
            result = result.replace(anchorRegex, (match, href, target, rel, content) => {
                const placeholder = `__ANCHOR_${placeholderIndex}__`;
                const escapedHref = escapeHtml(href);
                const escapedContent = escapeHtml(content);
                let tag = `<a href="${escapedHref}"`;
                if (target) {
                    tag += ` target="${escapeHtml(target)}"`;
                }
                if (rel) {
                    tag += ` rel="${escapeHtml(rel)}"`;
                }
                tag += `>${escapedContent}</a>`;
                tagPlaceholders[placeholder] = tag;
                placeholderIndex++;
                return placeholder;
            });

            // Protect other allowed tags
            allowedTags.forEach(tag => {
                if (tag === 'a') return; // Already handled
                const tagRegex = new RegExp(`<${tag}>(.*?)<\/${tag}>`, 'gi');
                result = result.replace(tagRegex, (match, content) => {
                    const placeholder = `__TAG_${placeholderIndex}__`;
                    tagPlaceholders[placeholder] = `<${tag}>${content}</${tag}>`;
                    placeholderIndex++;
                    return placeholder;
                });
            });

            // Escape everything else
            result = escapeHtml(result);

            // Restore protected tags
            Object.keys(tagPlaceholders).forEach(placeholder => {
                result = result.replace(placeholder, tagPlaceholders[placeholder]);
            });

            return result;
        }
        
        function escapeXmlWithFormatting(text) {
            const allowedTags = ['strong', 'em', 'u', 'sup', 'sub', 'code', 'a', 'b', 'i', 'pre'];
            let protected = text;
            const tagPlaceholders = {};
            let placeholderIndex = 0;

            // Protect LaTeX expressions (both inline and display)
            const latexPatterns = [
                { regex: /\\\[([\s\S]*?)\\\]/g, prefix: '\\[', suffix: '\\]' },
                { regex: /\\\(([\s\S]*?)\\\)/g, prefix: '\\(', suffix: '\\)' },
                { regex: /\$\$([\s\S]*?)\$\$/g, prefix: '$$', suffix: '$$' },
                { regex: /\$([^\$\n]+?)\$/g, prefix: '$', suffix: '$' }
            ];

            latexPatterns.forEach(pattern => {
                protected = protected.replace(pattern.regex, (match, content) => {
                    const placeholder = `__LATEX_${placeholderIndex}__`;
                    tagPlaceholders[placeholder] = pattern.prefix + content + pattern.suffix;
                    placeholderIndex++;
                    return placeholder;
                });
            });

            // Protect anchor tags with href and optional target
            const anchorRegex = /<a\s+href="([^"]+)"(?:\s+target="([^"]+)")?(?:\s+rel="([^"]+)")?[^>]*>(.*?)<\/a>/gi;
            protected = protected.replace(anchorRegex, (match, href, target, rel, content) => {
                const placeholder = `__ANCHOR_${placeholderIndex}__`;
                let tag = `<a href="${href}"`;
                if (target) {
                    tag += ` target="${target}"`;
                }
                if (rel) {
                    tag += ` rel="${rel}"`;
                }
                tag += `>${content}</a>`;
                tagPlaceholders[placeholder] = tag;
                placeholderIndex++;
                return placeholder;
            });
            
            // Protect pre>code blocks
            const preCodeRegex = /<pre><code(?:\s+class="([^"]+)")?(?:\s+data-language="([^"]+)")?>([\s\S]*?)<\/code><\/pre>/gi;
            protected = protected.replace(preCodeRegex, (match, className, lang, content) => {
                const placeholder = `__PRECODE_${placeholderIndex}__`;
                let tag = '<pre><code';
                if (className) {
                    tag += ` class="${className}"`;
                }
                if (lang) {
                    tag += ` data-language="${lang}"`;
                }
                // Escape the content inside code blocks
                const escapedContent = content
                    .replace(/&/g, '&amp;')
                    .replace(/</g, '&lt;')
                    .replace(/>/g, '&gt;');
                tag += `>${escapedContent}</code></pre>`;
                tagPlaceholders[placeholder] = tag;
                placeholderIndex++;
                return placeholder;
            });
            
            allowedTags.forEach(tag => {
                if (tag === 'a' || tag === 'pre') return; // Already handled
                const openRegex = new RegExp(`<${tag}>`, 'gi');
                const closeRegex = new RegExp(`</${tag}>`, 'gi');
                
                protected = protected.replace(openRegex, () => {
                    const placeholder = `__PLACEHOLDER_${placeholderIndex}__`;
                    tagPlaceholders[placeholder] = `<${tag}>`;
                    placeholderIndex++;
                    return placeholder;
                });
                
                protected = protected.replace(closeRegex, () => {
                    const placeholder = `__PLACEHOLDER_${placeholderIndex}__`;
                    tagPlaceholders[placeholder] = `</${tag}>`;
                    placeholderIndex++;
                    return placeholder;
                });
            });
            
            protected = String(protected)
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&apos;');
            
            Object.keys(tagPlaceholders).forEach(placeholder => {
                protected = protected.replace(placeholder, tagPlaceholders[placeholder]);
            });
            
            return protected;
        }
        
        function cleanText(text) {
            if (!text) return '';
            return text
                .replace(/\*\*/g, '')
                .replace(/\[/g, '')
                .replace(/\]/g, '')
                .replace(/\{\.underline\}/g, '')
                .replace(/\{\.mark\}/g, '')
                .trim();
        }
        
        function parseProblems(text) {
            const problems = [];
            
            let normalizedText = text
                .replace(/(\d+\.\s+[A-Z])/g, '\n$1')
                .replace(/(Part\s+\d+\s+Question\s+\d+)/gi, '\n\n$1\n')
                .replace(/(\*\*Original:)/gi, '\n\n$1');
            
            const lines = normalizedText.split('\n');
            
            let libraryOrg = 'MITxT';
            let libraryName = 'Problem Library';
            let libraryId = 'CustomLibrary';
            let displayNameLabel = '';
            let startIndex = 0;
            
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i].trim();
                if (line) {
                    const nameIdMatch = line.match(/^(.+?):\s*([A-Z0-9_]+)$/);
                    if (nameIdMatch && nameIdMatch[2].match(/^[A-Z0-9_]+$/)) {
                        libraryName = nameIdMatch[1].trim();
                        libraryId = nameIdMatch[2].trim();
                        continue;
                    }
                    
                    const orgMatch = line.match(/^Organization:\s*(.+?)(?:,|$)/i);
                    if (orgMatch) {
                        libraryOrg = orgMatch[1].trim();
                        continue;
                    }
                    
                    const nameMatch = line.match(/Legacy Library Name:\s*(.+?)(?:,|$)/i);
                    if (nameMatch) {
                        libraryName = nameMatch[1].trim();
                        continue;
                    }
                    
                    const idMatch = line.match(/Library ID:\s*(.+?)(?:,|$)/i);
                    if (idMatch) {
                        libraryId = idMatch[1].trim();
                        continue;
                    }
                    
                    const labelMatch = line.match(/^Label:\s*(.+)/i);
                    if (labelMatch) {
                        displayNameLabel = labelMatch[1].trim();
                        startIndex = i + 1;
                        break;
                    }
                    
                    const partQuestionMatch = line.match(/^Part\s+\d+\s+Question\s+\d+/i);
                    if (partQuestionMatch) {
                        displayNameLabel = line.trim();
                        startIndex = i + 1;
                        break;
                    }
                    
                    if (line.match(/^Part\s+\d+$/i)) {
                        continue;
                    }
                    
                    if (line.endsWith('?') || line.match(/^\d+\.\s+/) || line.match(/^Original:/i)) {
                        startIndex = i;
                        break;
                    }
                }
            }
            
            let questionText = '';
            let choices = [];
            let correctIndices = [];
            let explanation = '';
            let problemCount = 0;
            let inChoices = false;
            let currentLabel = '';
            
            for (let i = startIndex; i < lines.length; i++) {
                const line = lines[i].trim();
                
                const labelMatch = line.match(/^Label:\s*(.+)/i);
                if (labelMatch) {
                    if (questionText && choices.length > 0) {
                        problemCount++;
                        const displayName = currentLabel || displayNameLabel || `Problem ${problemCount}`;
                        problems.push({
                            title: displayName,
                            question: cleanText(questionText),
                            choices: choices.map(c => cleanText(c.text)),
                            correctIndices: correctIndices,
                            isMultipleChoice: correctIndices.length <= 1,
                            explanation: explanation ? cleanText(explanation) : 'Add your explanation here'
                        });
                        questionText = '';
                        choices = [];
                        correctIndices = [];
                        explanation = '';
                        inChoices = false;
                    }
                    currentLabel = labelMatch[1].trim();
                    continue;
                }
                
                const partQuestionMatch = line.match(/^Part\s+\d+\s+Question\s+\d+/i);
                if (partQuestionMatch) {
                    if (questionText && choices.length > 0) {
                        problemCount++;
                        const displayName = currentLabel || displayNameLabel || `Problem ${problemCount}`;
                        problems.push({
                            title: displayName,
                            question: cleanText(questionText),
                            choices: choices.map(c => cleanText(c.text)),
                            correctIndices: correctIndices,
                            isMultipleChoice: correctIndices.length <= 1,
                            explanation: explanation ? cleanText(explanation) : 'Add your explanation here'
                        });
                        questionText = '';
                        choices = [];
                        correctIndices = [];
                        explanation = '';
                        inChoices = false;
                    }
                    currentLabel = line.trim();
                    continue;
                }
                
                if (!line) {
                    if (questionText && choices.length > 0) {
                        problemCount++;
                        const displayName = currentLabel || displayNameLabel || `Problem ${problemCount}`;
                        problems.push({
                            title: displayName,
                            question: cleanText(questionText),
                            choices: choices.map(c => cleanText(c.text)),
                            correctIndices: correctIndices,
                            isMultipleChoice: correctIndices.length <= 1,
                            explanation: explanation ? cleanText(explanation) : 'Add your explanation here'
                        });
                        questionText = '';
                        choices = [];
                        correctIndices = [];
                        explanation = '';
                        inChoices = false;
                    }
                    continue;
                }
                
                if (line.match(/^Part\s+\d+\s+Question\s+\d+/i) || 
                    line.match(/^\*\*Part\s+\d+\s+Question\s+\d+/i)) {
                    if (questionText && choices.length > 0) {
                        problemCount++;
                        const displayName = currentLabel || displayNameLabel || `Problem ${problemCount}`;
                        problems.push({
                            title: displayName,
                            question: cleanText(questionText),
                            choices: choices.map(c => cleanText(c.text)),
                            correctIndices: correctIndices,
                            isMultipleChoice: correctIndices.length <= 1,
                            explanation: explanation ? cleanText(explanation) : 'Add your explanation here'
                        });
                        questionText = '';
                        choices = [];
                        correctIndices = [];
                        explanation = '';
                        inChoices = false;
                    }
                    continue;
                }
                
                const originalMatch = line.match(/^Original:\s*(.+)/i) || line.match(/^\*\*Original:\s*(.+)/i);
                if (originalMatch) {
                    if (questionText && choices.length > 0) {
                        problemCount++;
                        const displayName = currentLabel || displayNameLabel || `Problem ${problemCount}`;
                        problems.push({
                            title: displayName,
                            question: cleanText(questionText),
                            choices: choices.map(c => cleanText(c.text)),
                            correctIndices: correctIndices,
                            isMultipleChoice: correctIndices.length <= 1,
                            explanation: explanation ? cleanText(explanation) : 'Add your explanation here'
                        });
                        choices = [];
                        correctIndices = [];
                        explanation = '';
                    }
                    
                    questionText = originalMatch[1];
                    
                    if (!questionText.endsWith('?') && !questionText.match(/\(select all that apply\)$/i)) {
                        let j = i + 1;
                        while (j < lines.length) {
                            const trimmedLine = lines[j].trim();
                            if (!trimmedLine || trimmedLine.toLowerCase().includes('(correct') ||
                                trimmedLine.match(/^\d+\.\s+/) || trimmedLine.match(/^Part\s+\d+/i)) {
                                break;
                            }
                            questionText += ' ' + trimmedLine;
                            if (trimmedLine.endsWith('?') || trimmedLine.match(/\(select all that apply\)$/i)) {
                                i = j;
                                break;
                            }
                            j++;
                        }
                        if (j > i + 1) {
                            i = j - 1;
                        }
                    }
                    
                    inChoices = true;
                    continue;
                }
                
                const numberedQuestionMatch = line.match(/^\d+\.\s+(.+)/);
                if (numberedQuestionMatch) {
                    if (questionText && choices.length > 0) {
                        problemCount++;
                        const displayName = currentLabel || displayNameLabel || `Problem ${problemCount}`;
                        problems.push({
                            title: displayName,
                            question: cleanText(questionText),
                            choices: choices.map(c => cleanText(c.text)),
                            correctIndices: correctIndices,
                            isMultipleChoice: correctIndices.length <= 1,
                            explanation: explanation ? cleanText(explanation) : 'Add your explanation here'
                        });
                        choices = [];
                        correctIndices = [];
                        explanation = '';
                    }
                    
                    questionText = numberedQuestionMatch[1];
                    
                    if (!questionText.endsWith('?') && !questionText.match(/\(select all that apply\)$/i)) {
                        let j = i + 1;
                        while (j < lines.length) {
                            const trimmedLine = lines[j].trim();
                            if (!trimmedLine || trimmedLine.toLowerCase().includes('(correct') ||
                                trimmedLine.match(/^\d+\.\s+/) || trimmedLine.match(/^Part\s+\d+/i)) {
                                break;
                            }
                            questionText += ' ' + trimmedLine;
                            if (trimmedLine.endsWith('?') || trimmedLine.match(/\(select all that apply\)$/i)) {
                                i = j;
                                break;
                            }
                            j++;
                        }
                        if (j > i + 1) {
                            i = j - 1;
                        }
                    }
                    
                    inChoices = true;
                    continue;
                }
                
                const selectAllPattern = /\(select all that apply\)$/i;
                const isQuestion = (line.endsWith('?') || selectAllPattern.test(line)) && !line.toLowerCase().startsWith('explanation');
                
                if (isQuestion) {
                    if (questionText && choices.length > 0) {
                        problemCount++;
                        const displayName = currentLabel || displayNameLabel || `Problem ${problemCount}`;
                        problems.push({
                            title: displayName,
                            question: cleanText(questionText),
                            choices: choices.map(c => cleanText(c.text)),
                            correctIndices: correctIndices,
                            isMultipleChoice: correctIndices.length <= 1,
                            explanation: explanation ? cleanText(explanation) : 'Add your explanation here'
                        });
                        choices = [];
                        correctIndices = [];
                        explanation = '';
                    }
                    
                    questionText = line;
                    inChoices = true;
                    continue;
                }
                
                const answerMatch = line.match(/^Answer:\s*(.+?)(?:Explanation:\s*(.+))?$/i);
                if (answerMatch && questionText && choices.length === 0) {
                    const answerValue = answerMatch[1].trim();
                    const inlineExplanation = answerMatch[2] ? answerMatch[2].trim() : '';
                    const isNumerical = /^-?\d+\.?\d*$/.test(answerValue) || /^-?\d*\.?\d+$/.test(answerValue);
                    
                    problemCount++;
                    const displayName = currentLabel || displayNameLabel || `Problem ${problemCount}`;
                    
                    problems.push({
                        title: displayName,
                        question: cleanText(questionText),
                        answer: answerValue,
                        answerType: isNumerical ? 'numerical' : 'text',
                        choices: [],
                        correctIndices: [],
                        isMultipleChoice: false,
                        explanation: inlineExplanation || explanation || 'Add your explanation here'
                    });
                    
                    questionText = '';
                    choices = [];
                    correctIndices = [];
                    explanation = '';
                    inChoices = false;
                    continue;
                }
                
                if (line.toLowerCase().startsWith('explanation:') || 
                    line.toLowerCase().startsWith('explain:') ||
                    line.toLowerCase() === 'explanation') {
                    inChoices = false;
                    explanation = line.replace(/^explanation:\s*/i, '').replace(/^explain:\s*/i, '');
                    if (!explanation || explanation.toLowerCase() === 'explanation') {
                        explanation = '';
                    }
                    continue;
                }
                
                if (!inChoices && questionText && choices.length > 0) {
                    explanation += (explanation ? ' ' : '') + line;
                    continue;
                }
                
                if (questionText && inChoices) {
                    const isCorrect = line.toLowerCase().includes('(correct)') || 
                                      line.toLowerCase().includes('(correct answer)') || 
                                      line.includes('**(correct');
                    const choiceText = line
                        .replace(/\*\*\(correct.*?\)\*\*/i, '')
                        .replace(/\(correct\s*answer\)/i, '')
                        .replace(/\(correct\)/i, '')
                        .replace(/\\$/, '')
                        .trim();
                    
                    if (choiceText) {
                        const looksLikeExplanation = choiceText.length > 150 || 
                            /^(this|the|a|an|because|since|as|it|bar|sales|survey|independent)/i.test(choiceText);
                        
                        if (looksLikeExplanation && choices.length >= 2 && !isCorrect) {
                            inChoices = false;
                            explanation = choiceText;
                        } else {
                            if (isCorrect) {
                                correctIndices.push(choices.length);
                            }
                            choices.push({ text: choiceText, correct: isCorrect });
                        }
                    }
                }
            }
            
            if (questionText && choices.length > 0) {
                problemCount++;
                const displayName = currentLabel || displayNameLabel || `Problem ${problemCount}`;
                problems.push({
                    title: displayName,
                    question: cleanText(questionText),
                    choices: choices.map(c => cleanText(c.text)),
                    correctIndices: correctIndices,
                    isMultipleChoice: correctIndices.length <= 1,
                    explanation: explanation ? cleanText(explanation) : 'Add your explanation here'
                });
            }
            
            return {
                problems: problems,
                displayNameLabel: displayNameLabel || 'Problem',
                libraryOrg: libraryOrg,
                libraryName: libraryName,
                libraryId: libraryId
            };
        }
        
        function generateOLX(problems) {
            // Use array and join for better performance than string concatenation
            const olxParts = problems.map(problem => {
                const displayName = problem.title;
                const parts = [];

                if (problem.answerType === 'numerical') {
                    parts.push(
                        `<problem display_name="${escapeXml(displayName)}" markdown="null">`,
                        `  <numericalresponse answer="${escapeXml(problem.answer || '')}">`,
                        `    <label>${escapeXmlWithFormatting(problem.question)}</label>`,
                        `    <textline/>`,
                        `  </numericalresponse>`,
                        `  <solution>`,
                        `    <div class="detailed-solution">`,
                        `      <p>Explanation</p>`,
                        `      <p>${escapeXmlWithFormatting(problem.explanation)}</p>`,
                        `    </div>`,
                        `  </solution>`,
                        `</problem>`
                    );
                } else if (problem.answerType === 'text') {
                    parts.push(
                        `<problem display_name="${escapeXml(displayName)}" markdown="null">`,
                        `  <stringresponse answer="${escapeXml(problem.answer || '')}" type="ci">`,
                        `    <label>${escapeXmlWithFormatting(problem.question)}</label>`,
                        `    <textline size="40"/>`,
                        `  </stringresponse>`,
                        `  <solution>`,
                        `    <div class="detailed-solution">`,
                        `      <p>Explanation</p>`,
                        `      <p>${escapeXmlWithFormatting(problem.explanation)}</p>`,
                        `    </div>`,
                        `  </solution>`,
                        `</problem>`
                    );
                } else if (problem.isMultipleChoice) {
                    parts.push(
                        `<problem display_name="${escapeXml(displayName)}" markdown="null">`,
                        `  <multiplechoiceresponse>`,
                        `    <label>${escapeXmlWithFormatting(problem.question)}</label>`,
                        `    <choicegroup type="MultipleChoice">`
                    );

                    const choices = problem.choices || [];
                    const correctIndices = problem.correctIndices || [];
                    choices.forEach((choice, j) => {
                        const correct = correctIndices.includes(j) ? 'true' : 'false';
                        parts.push(`      <choice correct="${correct}">${escapeXmlWithFormatting(choice)}</choice>`);
                    });

                    parts.push(
                        `    </choicegroup>`,
                        `  </multiplechoiceresponse>`,
                        `  <solution>`,
                        `    <div class="detailed-solution">`,
                        `      <p>Explanation</p>`,
                        `      <p>${escapeXmlWithFormatting(problem.explanation)}</p>`,
                        `    </div>`,
                        `  </solution>`,
                        `</problem>`
                    );
                } else {
                    parts.push(
                        `<problem display_name="${escapeXml(displayName)}" markdown="null">`,
                        `  <choiceresponse>`,
                        `    <label>${escapeXmlWithFormatting(problem.question)}</label>`,
                        `    <checkboxgroup>`
                    );

                    const choices = problem.choices || [];
                    const correctIndices = problem.correctIndices || [];
                    choices.forEach((choice, j) => {
                        const correct = correctIndices.includes(j) ? 'true' : 'false';
                        parts.push(`      <choice correct="${correct}">${escapeXmlWithFormatting(choice)}</choice>`);
                    });

                    parts.push(
                        `    </checkboxgroup>`,
                        `  </choiceresponse>`,
                        `  <solution>`,
                        `    <div class="detailed-solution">`,
                        `      <p>Explanation</p>`,
                        `      <p>${escapeXmlWithFormatting(problem.explanation)}</p>`,
                        `    </div>`,
                        `  </solution>`,
                        `</problem>`
                    );
                }

                return parts.join('\n');
            });

            return olxParts.join('\n\n');
        }
        
        function updateStatistics(problems) {
            const stats = {
                total: problems.length,
                multipleChoice: 0,
                checkbox: 0,
                numerical: 0,
                text: 0,
                totalChoices: 0,
                choiceProblems: 0,
                warnings: 0
            };
            
            problems.forEach(p => {
                if (p.answerType === 'numerical') {
                    stats.numerical++;
                } else if (p.answerType === 'text') {
                    stats.text++;
                } else if (p.isMultipleChoice) {
                    stats.multipleChoice++;
                    if (p.choices) {
                        stats.totalChoices += p.choices.length;
                        stats.choiceProblems++;
                    }
                } else {
                    stats.checkbox++;
                    if (p.choices) {
                        stats.totalChoices += p.choices.length;
                        stats.choiceProblems++;
                    }
                }

                if (p.choices && p.choices.length > 0 && p.correctIndices && p.correctIndices.length === 0) {
                    stats.warnings++;
                }
                if (p.choices && p.choices.length < 2 && !p.answerType) {
                    stats.warnings++;
                }
            });
            
            const avgChoices = stats.choiceProblems > 0 ? (stats.totalChoices / stats.choiceProblems).toFixed(1) : '0';

            // Cache DOM queries for better performance
            const statElements = {
                total: document.querySelector('#stat-total .stat-value'),
                mc: document.querySelector('#stat-mc .stat-value'),
                checkbox: document.querySelector('#stat-checkbox .stat-value'),
                numerical: document.querySelector('#stat-numerical .stat-value'),
                text: document.querySelector('#stat-text .stat-value'),
                choices: document.querySelector('#stat-choices .stat-value'),
                warnings: document.querySelector('#stat-warnings .stat-value'),
                warningCard: document.getElementById('stat-warnings')
            };

            // Add null checks to prevent errors if elements don't exist
            if (statElements.total) statElements.total.textContent = stats.total;
            if (statElements.mc) statElements.mc.textContent = stats.multipleChoice;
            if (statElements.checkbox) statElements.checkbox.textContent = stats.checkbox;
            if (statElements.numerical) statElements.numerical.textContent = stats.numerical;
            if (statElements.text) statElements.text.textContent = stats.text;
            if (statElements.choices) statElements.choices.textContent = avgChoices;
            if (statElements.warnings) statElements.warnings.textContent = stats.warnings;

            if (statElements.warningCard) {
                statElements.warningCard.classList.remove('warning', 'error');
                if (stats.warnings > 0) {
                    statElements.warningCard.classList.add('warning');
                }
            }
        }
        
        function renderPreview(problems) {
            const container = document.getElementById('previewContainer');
            const countBadge = document.getElementById('previewCount');
            const nav = document.getElementById('previewNav');

            if (!container || !countBadge || !nav) {
                console.error('Preview elements not found in DOM');
                return;
            }

            countBadge.textContent = `${problems.length} Problem${problems.length !== 1 ? 's' : ''}`;

            if (problems.length === 0) {
                container.innerHTML = `
                    <div class="preview-empty">
                        <div class="preview-empty-icon">üìù</div>
                        <div>No problems to preview</div>
                    </div>
                `;
                nav.style.display = 'none';
                return;
            }

            nav.style.display = 'flex';

            if (showAllMode) {
                renderAllProblems(problems);
            } else {
                renderSingleProblem(problems, currentPreviewIndex);
            }

            updateNavInfo();
        }
        
        function renderAllProblems(problems) {
            const container = document.getElementById('previewContainer');
            if (!container) {
                console.error('Preview container not found');
                return;
            }
            container.innerHTML = problems.map((p, i) => renderProblemHTML(p, i)).join('');
            attachEditListeners();

            // Re-render MathJax equations
            if (window.MathJax && window.MathJax.typesetPromise) {
                window.MathJax.typesetPromise([container]).catch((err) => {
                    console.error('MathJax rendering error:', err);
                });
            }
        }

        function renderSingleProblem(problems, index) {
            const container = document.getElementById('previewContainer');
            if (!container) {
                console.error('Preview container not found');
                return;
            }
            if (!problems[index]) {
                container.innerHTML = '<div class="preview-empty"><div>Problem not found</div></div>';
                return;
            }
            container.innerHTML = renderProblemHTML(problems[index], index);
            attachEditListeners();

            // Re-render MathJax equations
            if (window.MathJax && window.MathJax.typesetPromise) {
                window.MathJax.typesetPromise([container]).catch((err) => {
                    console.error('MathJax rendering error:', err);
                });
            }
        }
        
        function renderProblemHTML(problem, index) {
            let typeClass = 'multiple-choice';
            let typeName = 'Single Choice';

            if (problem.answerType === 'numerical') {
                typeClass = 'numerical';
                typeName = 'Numerical';
            } else if (problem.answerType === 'text') {
                typeClass = 'text';
                typeName = 'Text Input';
            } else if (!problem.isMultipleChoice) {
                typeClass = 'checkbox';
                typeName = 'Multi-Select';
            }

            let choicesHTML = '';

            if (problem.answerType === 'numerical' || problem.answerType === 'text') {
                choicesHTML = `
                    <div class="preview-input-field">Enter your answer...</div>
                    <div class="preview-answer-hint">‚úì Correct answer:
                        <span class="editable" contenteditable="true" data-problem="${index}" data-field="answer">${escapeHtmlWithFormatting(problem.answer || '')}</span>
                    </div>
                `;
            } else {
                const indicatorClass = problem.isMultipleChoice ? '' : 'checkbox';
                const choices = problem.choices || [];
                const correctIndices = problem.correctIndices || [];
                choicesHTML = `
                    <ul class="preview-choices">
                        ${choices.map((choice, i) => `
                            <li class="preview-choice ${correctIndices.includes(i) ? 'correct' : ''}">
                                <div class="preview-choice-indicator ${indicatorClass}"></div>
                                <span class="preview-choice-text editable" contenteditable="true" data-problem="${index}" data-field="choice" data-choice="${i}">${escapeHtmlWithFormatting(choice)}</span>
                            </li>
                        `).join('')}
                    </ul>
                `;
            }

            return `
                <div class="preview-problem" data-index="${index}">
                    <div class="preview-problem-header">
                        <span class="preview-problem-title">${escapeHtmlWithFormatting(problem.title || '')}</span>
                        <span class="preview-problem-type ${typeClass}">${typeName}</span>
                    </div>
                    <div class="preview-question editable" contenteditable="true" data-problem="${index}" data-field="question">${escapeHtmlWithFormatting(problem.question || '')}</div>
                    ${choicesHTML}
                    <div class="preview-explanation">
                        <div class="preview-explanation-label">Explanation</div>
                        <div class="preview-explanation-text editable" contenteditable="true" data-problem="${index}" data-field="explanation">${escapeHtmlWithFormatting(problem.explanation || '')}</div>
                    </div>
                </div>
            `;
        }
        
        function attachEditListeners() {
            // Use event delegation to avoid memory leaks from duplicate listeners
            if (editListenersInitialized) return;

            const container = document.getElementById('previewContainer');
            if (!container) {
                console.error('Preview container not found for event listeners');
                return;
            }

            // Use event delegation on the parent container
            container.addEventListener('input', function(e) {
                if (e.target.classList.contains('editable')) {
                    handleEdit(e);
                }
            });

            container.addEventListener('focus', function(e) {
                if (e.target.classList.contains('editable')) {
                    handleFocus(e);
                }
            }, true); // Use capture phase for focus

            container.addEventListener('blur', function(e) {
                if (e.target.classList.contains('editable')) {
                    handleBlur(e);
                }
            }, true); // Use capture phase for blur

            container.addEventListener('keydown', function(e) {
                if (e.target.classList.contains('editable')) {
                    handleKeydown(e);
                }
            });

            editListenersInitialized = true;
        }
        
        function handleEdit(e) {
            const el = e.target;
            const problemIndex = parseInt(el.dataset.problem, 10);
            const field = el.dataset.field;
            const choiceIndex = el.dataset.choice !== undefined ? parseInt(el.dataset.choice, 10) : null;

            if (isNaN(problemIndex) || !currentProblems[problemIndex]) return;
            if (choiceIndex !== null && isNaN(choiceIndex)) return;

            const content = el.innerHTML;

            if (field === 'question') {
                currentProblems[problemIndex].question = content;
            } else if (field === 'explanation') {
                currentProblems[problemIndex].explanation = content;
            } else if (field === 'choice' && choiceIndex !== null) {
                if (currentProblems[problemIndex].choices && currentProblems[problemIndex].choices[choiceIndex] !== undefined) {
                    currentProblems[problemIndex].choices[choiceIndex] = content;
                }
            } else if (field === 'answer') {
                currentProblems[problemIndex].answer = content;
            }
            
            // Update OLX output
            updateOLXOutput();
        }
        
        function handleFocus(e) {
            document.getElementById('editIndicator').style.display = 'inline-flex';
        }
        
        function handleBlur(e) {
            setTimeout(() => {
                if (!document.querySelector('.editable:focus')) {
                    document.getElementById('editIndicator').style.display = 'none';
                }
            }, 100);
        }
        
        function handleKeydown(e) {
            if (e.ctrlKey || e.metaKey) {
                switch (e.key.toLowerCase()) {
                    case 'b':
                        e.preventDefault();
                        formatText('bold');
                        break;
                    case 'i':
                        e.preventDefault();
                        formatText('italic');
                        break;
                    case 'u':
                        e.preventDefault();
                        formatText('underline');
                        break;
                    case 'k':
                        e.preventDefault();
                        showLinkDialog();
                        break;
                    case '`':
                        e.preventDefault();
                        wrapInlineCode();
                        break;
                }
            }
        }
        
        function formatText(command) {
            document.execCommand(command, false, null);
            updateAfterFormat();
        }
        
        function wrapInlineCode() {
            const selection = window.getSelection();
            if (selection.rangeCount > 0) {
                const range = selection.getRangeAt(0);
                const selectedText = range.toString();
                const code = document.createElement('code');
                code.textContent = selectedText || 'code';
                range.deleteContents();
                range.insertNode(code);
                
                // Move cursor after the code element
                range.setStartAfter(code);
                range.setEndAfter(code);
                selection.removeAllRanges();
                selection.addRange(range);
            }
            updateAfterFormat();
        }
        
        function showCodeDialog() {
            const codeContent = document.getElementById('codeContent');
            const codeType = document.getElementById('codeType');
            const codeLanguage = document.getElementById('codeLanguage');
            const codeDialog = document.getElementById('codeDialog');

            if (!codeContent || !codeType || !codeLanguage || !codeDialog) {
                console.error('Code dialog elements not found');
                return;
            }

            // Save current selection
            const selection = window.getSelection();
            if (selection.rangeCount > 0) {
                savedSelection = selection.getRangeAt(0).cloneRange();
                const selectedText = selection.toString();
                codeContent.value = selectedText;
            } else {
                codeContent.value = '';
            }
            codeType.value = 'inline';
            codeLanguage.value = '';
            codeDialog.classList.add('visible');
            codeContent.focus();
        }

        function closeCodeDialog() {
            const codeDialog = document.getElementById('codeDialog');
            if (codeDialog) {
                codeDialog.classList.remove('visible');
            }
            savedSelection = null;
        }
        
        function insertCodeBlock() {
            const codeType = document.getElementById('codeType').value;
            const language = document.getElementById('codeLanguage').value.trim();
            const content = document.getElementById('codeContent').value;
            
            if (!content) {
                alert('Please enter some code');
                return;
            }
            
            if (savedSelection) {
                const selection = window.getSelection();
                selection.removeAllRanges();
                selection.addRange(savedSelection);
                
                let codeElement;
                
                if (codeType === 'block') {
                    // Create a pre > code structure for block code
                    const pre = document.createElement('pre');
                    codeElement = document.createElement('code');
                    if (language) {
                        codeElement.className = `language-${language}`;
                        codeElement.dataset.language = language;
                    }
                    codeElement.textContent = content;
                    pre.appendChild(codeElement);
                    codeElement = pre;
                } else {
                    // Inline code
                    codeElement = document.createElement('code');
                    codeElement.textContent = content;
                }
                
                savedSelection.deleteContents();
                savedSelection.insertNode(codeElement);
                
                // Move cursor after the code element
                savedSelection.setStartAfter(codeElement);
                savedSelection.setEndAfter(codeElement);
                selection.removeAllRanges();
                selection.addRange(savedSelection);
            }
            
            closeCodeDialog();
            updateAfterFormat();
        }

        function showLatexDialog() {
            const latexContent = document.getElementById('latexContent');
            const latexType = document.getElementById('latexType');
            const latexDialog = document.getElementById('latexDialog');

            if (!latexContent || !latexType || !latexDialog) {
                console.error('LaTeX dialog elements not found');
                return;
            }

            // Save current selection
            const selection = window.getSelection();
            if (selection.rangeCount > 0) {
                savedSelection = selection.getRangeAt(0).cloneRange();
                const selectedText = selection.toString();
                latexContent.value = selectedText;
            } else {
                latexContent.value = '';
            }
            latexType.value = 'inline';
            latexDialog.classList.add('visible');
            latexContent.focus();
            updateLatexPreview();
        }

        function closeLatexDialog() {
            const latexDialog = document.getElementById('latexDialog');
            if (latexDialog) {
                latexDialog.classList.remove('visible');
            }
            savedSelection = null;
        }

        function updateLatexPreview() {
            const contentEl = document.getElementById('latexContent');
            const typeEl = document.getElementById('latexType');
            const preview = document.getElementById('latexPreview');

            if (!contentEl || !typeEl || !preview) {
                console.error('LaTeX preview elements not found');
                return;
            }

            const content = contentEl.value;
            const type = typeEl.value;

            if (!content) {
                preview.innerHTML = '<em style="color: var(--text-muted);">Enter LaTeX code to see preview...</em>';
                return;
            }

            let formatted;
            switch(type) {
                case 'inline':
                    formatted = `\\(${content}\\)`;
                    break;
                case 'inline-dollar':
                    formatted = `$${content}$`;
                    break;
                case 'display':
                    formatted = `\\[${content}\\]`;
                    break;
                case 'display-dollar':
                    formatted = `$$${content}$$`;
                    break;
            }

            preview.textContent = formatted;

            // Trigger MathJax to render
            if (window.MathJax && window.MathJax.typesetPromise) {
                window.MathJax.typesetPromise([preview]).catch((err) => {
                    preview.innerHTML = '<span style="color: #ff5555;">Error rendering LaTeX</span>';
                    console.error('MathJax error:', err);
                });
            }
        }

        function validateLatexBalance(content) {
            // Check for balanced delimiters (only check regular braces, brackets, parentheses)
            // Note: \{, \}, \[, \], \(, \) are LaTeX escape sequences and shouldn't be counted
            const checks = [
                { open: '{', close: '}', name: 'curly braces' },
                { open: '[', close: ']', name: 'square brackets' },
                { open: '(', close: ')', name: 'parentheses' }
            ];

            for (const {open, close, name} of checks) {
                // Count only non-escaped delimiters
                // Use negative lookbehind to exclude \{, \[, \( etc.
                try {
                    const openRegex = new RegExp(`(?<!\\\\)\\${open}`, 'g');
                    const closeRegex = new RegExp(`(?<!\\\\)\\${close}`, 'g');
                    const openCount = (content.match(openRegex) || []).length;
                    const closeCount = (content.match(closeRegex) || []).length;

                    if (openCount !== closeCount) {
                        return { valid: false, message: `Unbalanced ${name}: ${openCount} opening, ${closeCount} closing` };
                    }
                } catch (e) {
                    // Fallback for browsers that don't support lookbehind
                    const openCount = (content.match(new RegExp(`\\${open}`, 'g')) || []).length;
                    const closeCount = (content.match(new RegExp(`\\${close}`, 'g')) || []).length;

                    if (openCount !== closeCount) {
                        return { valid: false, message: `Unbalanced ${name}` };
                    }
                }
            }

            return { valid: true };
        }

        // Chuck Norris Quote Functions
        async function showChuckNorrisQuote() {
            const dialog = document.getElementById('chuckNorrisDialog');
            if (!dialog) {
                console.error('Chuck Norris dialog not found');
                return;
            }
            dialog.classList.add('visible');
            await fetchNewChuckNorrisQuote();
        }

        async function fetchNewChuckNorrisQuote() {
            const quoteContent = document.getElementById('chuckNorrisQuoteContent');
            if (!quoteContent) {
                console.error('Chuck Norris quote content element not found');
                return;
            }

            quoteContent.innerHTML = '<span style="opacity: 0.5;">Loading...</span>';

            try {
                const response = await fetch('https://api.chucknorris.io/jokes/random');
                if (!response.ok) {
                    throw new Error('Failed to fetch quote');
                }
                const data = await response.json();
                if (data && data.value) {
                    quoteContent.innerHTML = `<span>${escapeHtml(data.value)}</span>`;
                } else {
                    quoteContent.innerHTML = '<span style="color: #ff5555;">Invalid quote data received.</span>';
                }
            } catch (error) {
                quoteContent.innerHTML = '<span style="color: #ff5555;">Error loading quote. Please try again.</span>';
                console.error('Chuck Norris API error:', error);
            }
        }

        function closeChuckNorrisDialog() {
            const dialog = document.getElementById('chuckNorrisDialog');
            if (dialog) {
                dialog.classList.remove('visible');
            }
        }

        function insertLatex() {
            const type = document.getElementById('latexType').value;
            const content = document.getElementById('latexContent').value;

            if (!content) {
                alert('Please enter LaTeX code');
                return;
            }

            // Validate balanced delimiters
            const validation = validateLatexBalance(content);
            if (!validation.valid) {
                alert(`LaTeX validation warning: ${validation.message}\nDo you want to insert anyway?`);
                // Continue anyway - user might know what they're doing
            }

            let formatted;
            switch(type) {
                case 'inline':
                    formatted = `\\(${content}\\)`;
                    break;
                case 'inline-dollar':
                    formatted = `$${content}$`;
                    break;
                case 'display':
                    formatted = `\\[${content}\\]`;
                    break;
                case 'display-dollar':
                    formatted = `$$${content}$$`;
                    break;
            }

            if (savedSelection) {
                const selection = window.getSelection();
                selection.removeAllRanges();
                selection.addRange(savedSelection);

                const textNode = document.createTextNode(formatted);
                savedSelection.deleteContents();
                savedSelection.insertNode(textNode);

                // Move cursor after the inserted text
                savedSelection.setStartAfter(textNode);
                savedSelection.setEndAfter(textNode);
                selection.removeAllRanges();
                selection.addRange(savedSelection);
            }

            closeLatexDialog();
            updateAfterFormat();

            // Re-render MathJax in the preview
            if (window.MathJax && window.MathJax.typesetPromise) {
                setTimeout(() => {
                    const previewContainer = document.getElementById('previewContainer');
                    if (previewContainer) {
                        window.MathJax.typesetPromise([previewContainer]).catch((err) => {
                            console.error('MathJax rendering error:', err);
                        });
                    }
                }, 100);
            }
        }

        function showLinkDialog() {
            const linkText = document.getElementById('linkText');
            const linkUrl = document.getElementById('linkUrl');
            const linkDialog = document.getElementById('linkDialog');

            if (!linkText || !linkUrl || !linkDialog) {
                console.error('Link dialog elements not found');
                return;
            }

            // Save current selection
            const selection = window.getSelection();
            if (selection.rangeCount > 0) {
                savedSelection = selection.getRangeAt(0).cloneRange();
                linkText.value = selection.toString();
            }
            linkUrl.value = '';
            linkDialog.classList.add('visible');
            linkUrl.focus();
        }

        function closeLinkDialog() {
            const linkDialog = document.getElementById('linkDialog');
            if (linkDialog) {
                linkDialog.classList.remove('visible');
            }
            savedSelection = null;
        }
        
        function insertLink() {
            const url = document.getElementById('linkUrl').value;
            const text = document.getElementById('linkText').value;
            const openInNewTab = document.getElementById('linkTarget').checked;
            
            if (!url) {
                alert('Please enter a URL');
                return;
            }
            
            if (savedSelection) {
                const selection = window.getSelection();
                selection.removeAllRanges();
                selection.addRange(savedSelection);
                
                const link = document.createElement('a');
                link.href = url;
                if (openInNewTab) {
                    link.target = '_blank';
                    link.rel = 'noopener noreferrer';
                }
                link.textContent = text || url;
                
                savedSelection.deleteContents();
                savedSelection.insertNode(link);
                
                // Move cursor after link
                savedSelection.setStartAfter(link);
                savedSelection.setEndAfter(link);
                selection.removeAllRanges();
                selection.addRange(savedSelection);
            }
            
            closeLinkDialog();
            updateAfterFormat();
        }
        
        function removeLink() {
            document.execCommand('unlink', false, null);
            updateAfterFormat();
        }
        
        function updateAfterFormat() {
            // Trigger input event on focused editable
            const focused = document.querySelector('.editable:focus');
            if (focused) {
                focused.dispatchEvent(new Event('input', { bubbles: true }));
            }
        }
        
        function updateOLXOutput() {
            const output = document.getElementById('output');
            if (!output) {
                console.error('Output element not found');
                return;
            }
            const olx = generateOLX(currentProblems);
            output.textContent = olx;
        }

        function updateNavInfo() {
            const navInfo = document.getElementById('previewNavInfo');
            if (!navInfo) {
                console.error('Preview nav info element not found');
                return;
            }
            if (showAllMode) {
                navInfo.textContent = `Showing all ${currentProblems.length}`;
            } else {
                navInfo.textContent = `${currentPreviewIndex + 1} of ${currentProblems.length}`;
            }
        }
        
        function prevProblem() {
            if (currentProblems.length === 0) return;
            showAllMode = false;
            currentPreviewIndex = (currentPreviewIndex - 1 + currentProblems.length) % currentProblems.length;
            renderSingleProblem(currentProblems, currentPreviewIndex);
            updateNavInfo();
        }
        
        function nextProblem() {
            if (currentProblems.length === 0) return;
            showAllMode = false;
            currentPreviewIndex = (currentPreviewIndex + 1) % currentProblems.length;
            renderSingleProblem(currentProblems, currentPreviewIndex);
            updateNavInfo();
        }
        
        function showAllProblems() {
            showAllMode = true;
            renderAllProblems(currentProblems);
            updateNavInfo();
        }
        
        function togglePreview() {
            previewEnabled = !previewEnabled;
            const toggle = document.getElementById('previewToggle');
            const grid = document.getElementById('mainGrid');
            const panel = document.getElementById('previewPanel');

            if (!toggle || !grid || !panel) {
                console.error('Preview toggle elements not found');
                return;
            }

            toggle.classList.toggle('active', previewEnabled);

            if (previewEnabled) {
                grid.classList.add('three-col');
                panel.style.display = 'flex';
            } else {
                grid.classList.remove('three-col');
                panel.style.display = 'none';
            }
        }
        
        function convertToOLX() {
            const input = document.getElementById('input').value;
            const output = document.getElementById('output');
            
            if (!input.trim()) {
                showStatus('Please enter problem text to convert', 'error');
                return;
            }
            
            try {
                const result = parseProblems(input);
                const problems = result.problems;
                
                if (problems.length === 0) {
                    showStatus('No problems found. Please check your input format.', 'error');
                    return;
                }
                
                currentProblems = problems;
                currentPreviewIndex = 0;
                showAllMode = true;
                
                const olx = generateOLX(problems);
                output.textContent = olx;
                
                updateStatistics(problems);
                
                if (previewEnabled) {
                    renderPreview(problems);
                }
                
                const labelMsg = result.displayNameLabel ? ` (using label: "${result.displayNameLabel}")` : '';
                showStatus(`Successfully converted ${problems.length} problem(s)${labelMsg} - Click text in preview to edit`, 'success');
            } catch (error) {
                showStatus(`Error: ${error.message}`, 'error');
                console.error(error);
            }
        }
        
        function copyOutput() {
            const output = document.getElementById('output');
            const text = output.textContent;
            
            if (!text || text === 'OLX output will appear here...') {
                showStatus('No output to copy', 'error');
                return;
            }
            
            navigator.clipboard.writeText(text).then(() => {
                showStatus('Copied to clipboard!', 'success');
            }).catch(err => {
                showStatus('Failed to copy', 'error');
            });
        }
        
        function downloadOutput() {
            const output = document.getElementById('output');
            const text = output.textContent;
            
            if (!text || text === 'OLX output will appear here...') {
                showStatus('No output to download', 'error');
                return;
            }
            
            const blob = new Blob([text], { type: 'text/xml' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'problems.xml';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            showStatus('Downloaded problems.xml', 'success');
        }
        
        function generateUUID() {
            return 'xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx'.replace(/x/g, function() {
                return Math.floor(Math.random() * 16).toString(16);
            });
        }
        
        function generateSingleProblemXML(problem, index) {
            const displayName = problem.title;
            const parts = [`<problem display_name="${escapeXml(displayName)}" markdown="null">`];

            if (problem.answerType === 'numerical') {
                parts.push(
                    `  <numericalresponse answer="${escapeXml(problem.answer || '')}">`,
                    `    <label>${escapeXmlWithFormatting(problem.question)}</label>`,
                    `    <textline/>`,
                    `  </numericalresponse>`
                );
            } else if (problem.answerType === 'text') {
                parts.push(
                    `  <stringresponse answer="${escapeXml(problem.answer || '')}" type="ci">`,
                    `    <label>${escapeXmlWithFormatting(problem.question)}</label>`,
                    `    <textline size="40"/>`,
                    `  </stringresponse>`
                );
            } else if (problem.isMultipleChoice) {
                parts.push(
                    `  <multiplechoiceresponse>`,
                    `    <label>${escapeXmlWithFormatting(problem.question)}</label>`,
                    `    <choicegroup type="MultipleChoice">`
                );

                const choices = problem.choices || [];
                const correctIndices = problem.correctIndices || [];
                choices.forEach((choice, j) => {
                    const correct = correctIndices.includes(j) ? 'true' : 'false';
                    parts.push(`      <choice correct="${correct}">${escapeXmlWithFormatting(choice)}</choice>`);
                });

                parts.push(
                    `    </choicegroup>`,
                    `  </multiplechoiceresponse>`
                );
            } else {
                parts.push(
                    `  <choiceresponse>`,
                    `    <label>${escapeXmlWithFormatting(problem.question)}</label>`,
                    `    <checkboxgroup>`
                );

                const choices = problem.choices || [];
                const correctIndices = problem.correctIndices || [];
                choices.forEach((choice, j) => {
                    const correct = correctIndices.includes(j) ? 'true' : 'false';
                    parts.push(`      <choice correct="${correct}">${escapeXmlWithFormatting(choice)}</choice>`);
                });

                parts.push(
                    `    </checkboxgroup>`,
                    `  </choiceresponse>`
                );
            }

            parts.push(
                `  <solution>`,
                `    <div class="detailed-solution">`,
                `      <p>Explanation</p>`,
                `      <p>${escapeXmlWithFormatting(problem.explanation)}</p>`,
                `    </div>`,
                `  </solution>`,
                `</problem>`
            );

            return parts.join('\n');
        }
        
        async function downloadLibrary() {
            if (currentProblems.length === 0) {
                showStatus('No problems to export. Convert problems first.', 'error');
                return;
            }
            
            try {
                const input = document.getElementById('input').value;
                const result = parseProblems(input);
                
                const problemXMLs = currentProblems.map((problem, index) => {
                    const problemId = `problem_${generateUUID()}`;
                    return {
                        id: problemId,
                        filename: `${problemId}.xml`,
                        content: generateSingleProblemXML(problem, index)
                    };
                });
                
                let libraryXML = `<library display_name="${escapeXml(result.libraryName)}">\n`;
                for (const pf of problemXMLs) {
                    libraryXML += `  <problem url_name="${pf.id}"/>\n`;
                }
                libraryXML += `</library>`;
                
                const zip = new JSZip();
                const safeLibraryId = result.libraryId.replace(/[^a-zA-Z0-9_-]/g, '_');
                const library = zip.folder(safeLibraryId);
                const problemFolder = library.folder('problem');
                const policiesFolder = library.folder('policies');
                
                for (const pf of problemXMLs) {
                    problemFolder.file(pf.filename, pf.content);
                }
                
                library.file('library.xml', libraryXML);
                policiesFolder.file('assets.json', '{}');
                
                const content = await zip.generateAsync({ 
                    type: 'blob',
                    compression: "DEFLATE",
                    compressionOptions: { level: 9 }
                });
                
                const url = URL.createObjectURL(content);
                const a = document.createElement('a');
                a.href = url;
                a.download = `${safeLibraryId}.zip`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                showStatus(`Downloaded ${safeLibraryId}.zip with ${currentProblems.length} problems (with edits)`, 'success');
            } catch (error) {
                showStatus(`Error creating library: ${error.message}`, 'error');
                console.error(error);
            }
        }
        
        function clearAll() {
            document.getElementById('input').value = '';
            document.getElementById('output').textContent = 'OLX output will appear here...';
            document.getElementById('status').style.display = 'none';
            currentProblems = [];
            currentPreviewIndex = 0;
            
            document.querySelectorAll('.stat-value').forEach(el => el.textContent = '0');
            document.getElementById('stat-warnings').classList.remove('warning', 'error');
            
            renderPreview([]);
        }
        
        function loadSample() {
            const sample = `Module 3 - Assignment 1 - Part 1 - Question 1: UAI0_A01_P01_Q01

Label: Part 1 Question 1

Original: What type of data is best visualized with a bar chart?
Continuous time series data
Relationships between variables
Discrete categorical comparisons (correct)
Cumulative totals

Explanation: Bar charts are ideal for comparing discrete categories side by side, making it easy to see differences between groups.

1. Which of the following are data visualization tools? (Select all that apply)
Tableau (correct)
Microsoft Word
Python matplotlib (correct)
Adobe Photoshop
Power BI (correct)

Explanation: Tableau, matplotlib, and Power BI are all specialized data visualization tools designed for creating charts and graphs.

2. Which scenario is best suited for a bar chart?
Comparing sales across product categories (correct)
Tracking stock prices throughout the day
Examining the relationship between two numerical variables
Plotting a sine wave

Explanation: Product categories represent distinct groups that can be effectively compared using bars of different heights.

3. What is 2 + 2?
Answer: 4

Explanation: Basic arithmetic shows that two plus two equals four.`;
            
            document.getElementById('input').value = sample;
            showStatus('Sample data loaded - click Convert to see editable preview', 'success');
        }
        
        function handleFileUpload(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            if (file.name.endsWith('.docx')) {
                const reader = new FileReader();
                
                reader.onload = function(e) {
                    const arrayBuffer = e.target.result;
                    
                    mammoth.convertToHtml({arrayBuffer: arrayBuffer}, {
                        styleMap: [
                            "p[style-name='Heading 1'] => h1:fresh",
                            "p[style-name='Heading 2'] => h2:fresh",
                            "b => strong",
                            "i => em",
                            "u => u"
                        ]
                    })
                        .then(function(result) {
                            const html = result.value;
                            const tempDiv = document.createElement('div');
                            tempDiv.innerHTML = html;
                            
                            let text = '';
                            const processNode = (node) => {
                                if (node.nodeType === Node.TEXT_NODE) {
                                    return node.textContent;
                                }
                                
                                if (node.nodeType === Node.ELEMENT_NODE) {
                                    const tag = node.tagName.toLowerCase();
                                    let content = '';
                                    
                                    for (let child of node.childNodes) {
                                        content += processNode(child);
                                    }
                                    
                                    switch(tag) {
                                        case 'strong':
                                        case 'b':
                                            return `<strong>${content}</strong>`;
                                        case 'em':
                                        case 'i':
                                            return `<em>${content}</em>`;
                                        case 'u':
                                            return `<u>${content}</u>`;
                                        case 'sup':
                                            return `<sup>${content}</sup>`;
                                        case 'sub':
                                            return `<sub>${content}</sub>`;
                                        case 'code':
                                            return `<code>${content}</code>`;
                                        case 'p':
                                        case 'li':
                                            return content + '\n';
                                        case 'br':
                                            return '\n';
                                        default:
                                            return content;
                                    }
                                }
                                return '';
                            };
                            
                            const paragraphs = tempDiv.querySelectorAll('p, li');
                            if (paragraphs.length > 0) {
                                paragraphs.forEach(p => {
                                    const processed = processNode(p);
                                    if (processed.trim()) {
                                        text += processed;
                                    }
                                });
                            } else {
                                text = processNode(tempDiv);
                            }
                            
                            document.getElementById('input').value = text;
                            showStatus(`Loaded ${file.name} (converted from Word with formatting)`, 'success');
                        })
                        .catch(function(err) {
                            console.error('Error reading Word document:', err);
                            showStatus('Error reading Word document', 'error');
                        });
                };
                
                reader.onerror = function() {
                    showStatus('Error reading file', 'error');
                };
                
                reader.readAsArrayBuffer(file);
            } else {
                const reader = new FileReader();
                
                reader.onload = function(e) {
                    const text = e.target.result;
                    document.getElementById('input').value = text;
                    showStatus(`Loaded ${file.name}`, 'success');
                };
                
                reader.onerror = function() {
                    showStatus('Error reading file', 'error');
                };
                
                reader.readAsText(file);
            }
        }
        
        function showStatus(message, type) {
            const status = document.getElementById('status');
            if (!status) {
                console.error('Status element not found');
                return;
            }
            status.textContent = message;
            status.className = `status ${type}`;
            status.style.display = 'block';

            setTimeout(() => {
                status.style.display = 'none';
            }, 4000);
        }
        
        // Handle link dialog with Enter key
        const linkUrl = document.getElementById('linkUrl');
        if (linkUrl) {
            linkUrl.addEventListener('keydown', function(e) {
                if (e.key === 'Enter') {
                    insertLink();
                } else if (e.key === 'Escape') {
                    closeLinkDialog();
                }
            });
        }

        const linkText = document.getElementById('linkText');
        if (linkText) {
            linkText.addEventListener('keydown', function(e) {
                if (e.key === 'Enter') {
                    insertLink();
                } else if (e.key === 'Escape') {
                    closeLinkDialog();
                }
            });
        }

        // Close dialog when clicking overlay
        const linkDialog = document.getElementById('linkDialog');
        if (linkDialog) {
            linkDialog.addEventListener('click', function(e) {
                if (e.target === this) {
                    closeLinkDialog();
                }
            });
        }
        
        // Code dialog event listeners
        const codeContent = document.getElementById('codeContent');
        if (codeContent) {
            codeContent.addEventListener('keydown', function(e) {
                if (e.key === 'Escape') {
                    closeCodeDialog();
                }
                // Allow Tab for indentation in code
                if (e.key === 'Tab') {
                    e.preventDefault();
                    const start = this.selectionStart;
                    const end = this.selectionEnd;
                    this.value = this.value.substring(0, start) + '    ' + this.value.substring(end);
                    this.selectionStart = this.selectionEnd = start + 4;
                }
            });
        }

        const codeDialog = document.getElementById('codeDialog');
        if (codeDialog) {
            codeDialog.addEventListener('click', function(e) {
                if (e.target === this) {
                    closeCodeDialog();
                }
            });
        }

        // LaTeX dialog event listeners
        const latexContent = document.getElementById('latexContent');
        const latexType = document.getElementById('latexType');
        const latexDialog = document.getElementById('latexDialog');

        if (latexContent) {
            latexContent.addEventListener('input', updateLatexPreview);

            latexContent.addEventListener('keydown', function(e) {
                if (e.key === 'Escape') {
                    closeLatexDialog();
                }
                // Allow Tab for indentation
                if (e.key === 'Tab') {
                    e.preventDefault();
                    const start = this.selectionStart;
                    const end = this.selectionEnd;
                    this.value = this.value.substring(0, start) + '    ' + this.value.substring(end);
                    this.selectionStart = this.selectionEnd = start + 4;
                }
            });
        }

        if (latexType) {
            latexType.addEventListener('change', updateLatexPreview);
        }

        if (latexDialog) {
            latexDialog.addEventListener('click', function(e) {
                if (e.target === this) {
                    closeLatexDialog();
                }
            });
        }
    </script>
</body>
</html>
